# TODO

1. [ОК] Разобраться с лишним элементом JSON после парсинга в конце каждого массива
2. [ОК] Сделать более плавную ошибку... в layer.cpp 1680 Ошибка считается от 0 до 1 в слое ошибки. 
   По факту ошибка может быть в интервоале от 0 до ... и надо иметь возможность ее плавно задавать.
3. [OK] Запастить расчет через процессор отдельный
    1. [ОК] Много красных ошибок при выводе между резуолтом и сэмплом
    0. [ОК] Отправка с тичера слоев одним пкаетом что бы между ними не вклинился расчет процессора.
    0. [ОК] Сделать подгрузку картинки из папки без необходимости указаниыя файла для тичера TEACHER_TASK_IMAGE
    0. [ок] Найти развал в netread
    0. [ок] Убрать тормоза при отпраке Weight.
        1. [OK] Сделать остановку всех тредов при прочтении файла конфига нета
        0. [ОК] Опять проблема с остановкой сокета. Нужна разобраться с неблокирующими сокетами.
        0. [ОК] Перевести на тред тичера
        0. [OK] Перенести на тред ui.
        0. [ОК] SockManager - что бы не плодить открытые сокеты
            1. [ОК] сделать класс SockManager - как вектор открытых портов
            0. [ОК] перенести функционал sock.openHandle в sock.listen и sock.connect
            0. [ОК] сделать для Sock запрос к SockManager - возвращающий по номеру 
               потока хосту и порту сокет из пула либо создает новый порт
            0. [cancel] присобачить SockManager к io
            0. [cancel] при каждом обращзениии к Sock передавть указательна SockManager
        0. [ок] Разделить память на разные органы Limb.
            1. [ок] Limb - у каждого потока свой Limb объект net и один в главном потоке с которым все синхронятся.
                1. [ок] Net основного потока формируется при загрузке
                0. [Ок] Каждый участник 
                    1. [Ок] при создании имеет свой список лэйров и нервов копируя их из net.
                0. [cancel] HyperNet - net у всех общий но каждый поток получает персональный срез данных через net. 
                   Не можем придумать разрешение потока в указатель памяти pointer=f(thread).
                0. [cancel] BigNet - net общий но при этом в нем предусмотрены методы для всех участников для работы с данынми. 
                   Добавление участника приведет к изменению кода Net.
                0. [cancel] PairNet - у каждого участника один net имеющий основную и кэш память.
                   Нельзя объединять разных участников в одном приложении.
                0. [cancel] AloneNet - участники разделены на приложения и каждое приложение имеет свой нет.
                   Общение только через сервер.
            0. [ok] Переход на Limb 
                1. [оk] сервер
                0. [ок] UI
                    1. [ ОК ] Найти причину почему из нета не копируется Value в UI и вообще наладить комуникацию между net и иными участниками
                    0. [ ok ] разрешить проблему с event
                        1. [cancel] возможно появися LimbList для передачи в него евента net
                        0. [ок] 6избавиться от events
                        0. [cancel] для каждого участника создается очередь событий и каждый участник сам с ним возится... сложно и плохой варинат
                    0. Виснет сразу или после отрисовки нескольких кадров при загруженной с сервера сети.
                        1. [lost] Виснет на прочтении ответа от сервера rpc_client::call в read
                        0. [ок] В любом случае нужен таймаут ожидания ответа сервера
                        0. [ок] При неполном прочтении сети иногда валится с ошибкой
                    0. [ок] приделать Nerve для отображения
                0. [ok] Teacher
                    1. [ок] Проблема с предеклрацией Limb. LayerTeacher знает что есть некий Limb но не умеет с ним работать так как лимб появится позже. Надо что бы лимб был собрань раньше чем LayerTeacher.
                    0. [ок] Processor от Teacher не видит значений слоя. Подозрение - у процесора нет структуры слоев.
                        1. [ок] Алгоритм обмена слоями
                            1. [ок] Net работает не зависимо от иных лимбов по своему циклу
                            0. [ок] Каждый лимб может читать из нета и писать в него по своему усмотрению.
                            0. [ок] Net при очередном цикле измененные лимбами слои выкидывает на сервер
                            0. [ок] Если слои не изенялись то он их читает
                            0. [ок] Для реализации нужно два списка в net swapedValues swapedErros и методы addSwapedValues removeSwapedValues
                        0. [ок] Метод записи слоя с тичера на сервер валится. Тичер отсылает команду а сервер получает ункноун
                        0. [ок] Для Limb процессора не сгенерили WEIGHT план. При расчете процессор рассыпается.
                        0. [ок] сделать ошибку и отказ тичера при непрочтении файлов.
                0. [ок] Проблема синхронизации. Все слои (значения и ошибки) надо отправлять и читать в net на сервер синхронно.
                    1. [ок] Запрашиваются лишние слои из тичера read retina
                    0. [ок] Нужна реализация разбора структуры слоев на сервере для записи и чтения в нет сервера.
                        1. [ок] Сделали.  Не находит слоя. Shoggot IO error[string command READ_LAYERS][string code LayerUnknown 
                        0. [ок] Таки есть не синхрон результата и ретины. Не выполняется загрузка ретинового кота. Остается шум. В логе один imageLoad.
                        0. [ок] Тичер должен устанавливать value для ERROR. Обдумать.
        0. [ок] Жрет память парсинг JSON при раскодировани файла.
        0. [ок] Валятся UI и Teacher
        0. [ок] Валится прилоежние без ключей на выходе.
        0. [ok] Удалить (Переделать) supt на без сервера ptu. Проверить.
        0. [ок]Проверить момент загрузки сети для UI и Teacher и Processor (пересохранение всех конфигов должно вызывать перезагрузку сети).
            1. [ок]server 
                1. [ок] При перзапуске сервера (при чтении конфига) клиенты к нему не могут подключится 
                    1. [ok] Клиент не может сам переподключится и вываливается с ошибкой.
                0. Проверить результат изменения размера слоев 
                    1. [ок] Дохнет процесор Read net
                    0. [ок]Конфиг читается но не обновляется UI слои
            0. [ок] teacher
    0. [cancel] Надо что бы buildPTU учитывал не только наличие секции но и enabled (config)
0. Эксперименты с нейронкой
    1. [ок] Сохранение и чтение Weight для сервера.
    0. [ок] Модификация образов перед обучением, а имено сдвиги, повороты, размер.
    0. [ок] Сеть не обучается
        1. [ок] Надо сделать вывод весов. Создать WeightsExchange
        0. [ок] Сеть сходится к одному и тому же значению во всех весах после нескольких циклов обучения
        0. [ок] Проверить результат обучения
    0. Проверить влияние коэффициентов  расчета обучения на скорость обучения.
    0. Провести эксперементы по скорости обучения.
1. Иное
    0. [ОК] При отправке write в несуществующий сокет (закрыт сервер) приложение клиент получает SIGPIPE и закрывается. 
    0. [cancel] Ускорить работу ... найти где есть тормоза... возможно использовать Socket вместо IP для общения по сети
    0. [ok] Для тичера
        1. [ok] установить ловушку журнала на поток обучения.
        0. [ok] вывести в монитор последнее задание и текущий уровень ошибки.
1. Доработки
    1. [ок] Вывести weights на UI
        1. [ok] Написать WeightsExchange на UI
        0. [ok] На сервере сложить Weights для выбранных нейронов в Net из WeightsExchange
            1. [ok] Не удаляются записи о нейронах на сервере после снятия выбранных нейронов на UI
        0. [ок] Заполнить из процессора данные в Net->weightsExchange
            1. [ok] Какой то косяк... при выборе нейронов в контекс1 количество вейтов для ретины (родительские) не соответсвует количеству нейронов в ретин
        0. [ok] Заполнить в клиенте weightsExchange 
        0. [ок] Сделать вывод Weigths.
            1. [ок] Повесить вывод на кнопку W для выбраных нейронов.
        0. Сделать устаревание ранее запрошенных нейронов. что бы при потере клиента сервер не копипастил связи.
    0. Переименовать тичер в router.
    0. Для imageToValue сделать проверку наличия пути при чтении файла.
    0. Запустить проект через сеть. На арубе понадобиться сервер 20.04 gcc 13.*
    0. Возможность запуска множества сетей и возможность запуска наследуемых сетей. Для этого нужен корневой объект от кторого создаются остальные.
    0. Разбораться кто главнее ui или scenePayload и засунуть Scene в ScenePayload с учетом того что один пэйлоад может именть множество сцен..... или же надо менять пэйлоады а сцена одна. 
    0. Криво устанавливается связь один к одному между слоями если количество нейронов различно.
    0. Сделать нарезку в RPC на фрагменты размером с Пакет что бы протаскивать большие объемы.
    0. Модификация образов перед обучением, а имено градиентная яркость, инверсия, колоризация.

1. Ошибки
    1. При изменении структуры у тичера остается error. Процу считать нечего. Error не менятеся. Тичер виснет.
    0. Иногда крашится imagemagic или около него при заврешении работы со сценой при выходе из приложения Magick: abort due to signal 11 (SIGSEGV) "Segmentation Fault"....
    0. [ок] Сеть сваливается в NAN. Предположительно из за большого значения

1. Оптимизации
    1. Считает медленно. Надо найти причину или хотя бы место где тормоза
    0. Необходимо сделать мягкую презгрузку слоев после реконфигурации:
        1. Проходим все слои
            1. для существующих в конфиге и лимбе прописываем конфигурацию включая визуальную
            0. для существующих у которых различаются размеры пересоздаем error и view c последующим пересозданеим nerve
            0. удаляем из лимба отсутствующшие в конфиге
            0. добавляем присутствующие в конфиге
            0. применяем все выше пречисленое при копировании из net в limb
    0. Переделать рендр слоев через texture
        1. каждому слою UI отводим текстурный буффер
        0. организуем заполнение текстуры из сети
        0. выводим текстуру
    0. Сокет при остановке сервера остается в CLOSE_WAIT и висит.
    0. UI тормозит при выделении нейронов.
    0. Сделать много потоков для процессора. Каждый слой может обсчитываться в несколько потоков.
    0. Разобраться с прерываниями и гарантированно сносить процесс сервера со всеми его открытыми сокетами.
    0. Жрут память процессы still reachable...
    0. Проверить почему процесс расчета сети не забирает как минимум один процесс. Возможно для проца работает loopTimeoutMsec чего быть не должно.


1. Эволюция
    1. [ok] Переносим net.json в версию
    2. [ok] Переносим параметры в net/json с соответсвующими изменениями в процессах
        1. [ok] learningSpeed
        2. [ok] errorLimit
    3. [ок] Добавляем работу shoggoth_application текущую версю current.json
    4. [ок] Для сервера организуем иерархию версий на основе путей.
    5. [ок] Необходима конвертация ParamList в JSON формат строковый.
    6. [ок] Делаем для net метод Mutate с копированием в новый Net конфигов с внесением мутаций
    7. [ок] Для сервера добавляем новые методы
        1. [ок] cloneNet
        4. [ок] switchNet
    8. [ок] Создаем нового участника evolution 
        1. Необходим механизм определения изменения состояния значений слоев
            1. [ok] Добавляем в слои счетчик 
            2. [ок] Дoбавляем в сервер статистику на основе ChartList.
            3. [ок] Добавляем процессору инкремент счетчика если он не -1.
            4. [ok] Добавляем в протокол команду ДРОП счетчика при которой счетчик размещается в статистике и скидывается в 0.
            5. Добавляем впротокол запрос статистики по слою.
                1. Отладка BufferD1 <<<<<
            6. Эволюшен заправшивает статистику по ретине и анализирует статистику скорости обучения.
<<<<<<< HEAD
    1. UI тормозит прерыванием запроса нета
        1. [ок] Дописываем условие на проверку локов <<<
        2. [ок] При синхронизации с сервером сначала читаем все из сети ... и располагая всеми данными обновляем только после этого net при этом его блокируя.
=======
    1. [ok] UI тормозит прерыванием запроса нета
        1. [ок] Дописываем условие на проверку локов <<<
        2. [ok] При синхронизации с сервером сначала читаем все из сети ... и располагая всеми данными обновляем только после этого net при этом его блокируя.

>>>>>>> d795921 (Auto commit)
