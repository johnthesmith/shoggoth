#include "net.h"
#include "../json/param_object.h"


/*
    Constructor
*/
Net::Net
(
    Application* a    /* Log object */
)
{
    application = a;
    application -> getLog() -> trace( "Create net" );

    layers = new LayerList();
    nerves = new NerveList();
}




/*
    Constructor
*/
Net::~Net()
{
    clear();

    delete( nerves );
    delete( layers );

    getLog() -> trace( "Destroy net" );
}



/*
    Static constructor
*/
Net* Net::create
(
    Application* a
)
{
    return new Net( a );
}



/*
    Destructor
*/
void Net::destroy()
{
    delete ( this );
}




/*
    Create new nerve
*/
Nerve* Net::createNerve
(
    string      aId,            /* Nerve id */
    Layer*      aLayerFrom,     /* Layer source */
    Layer*      aLayerTo,       /* Layer destination */
    NerveType   aNerveType,
    BindType    aBindType,
    double      aMinWeight,
    double      aMaxWeight
)
{
    Nerve* result = Nerve::create
    (
        getLog(),
        aId,
        aLayerFrom,
        aLayerTo,
        aNerveType,
        aBindType,
        aMinWeight,
        aMaxWeight
    );
    nerves -> push( result );
    return result;
}



/*
    Delete layer by Id
*/
Net* Net::deleteNerve
(
    string a /* Id of layer */
)
{
    Nerve* nerve = nerves -> getById( a );

    if( nerve != NULL )
    {
        /* Remove nerve from net list */
        nerves -> remove( nerve );

        /* Destroy the nerve */
        nerve -> destroy();
    }
    return this;
}










/*
    Clear all layers
*/
Net* Net::clear()
{
    int c = layers -> getCount();
    for( int i = 0; i < c; i++ )
    {
        Layer* layer = ( Layer* ) layers -> getByIndex( i );
        layer -> destroy();
    }
    layers -> resize( 0 );
    return this;
}



/*
    Calculate all enabled layers
*/
Net* Net::resetCalc()
{
    loopParity = !loopParity;
    layers -> loop
    (
        [ this ]
        ( void* iLayer )
        {
            (( Layer* ) iLayer) -> setLoopParity( !loopParity );
            return false;
        }
    );
    return this;
}



/*
    Calculate all enabled layers
*/
Net* Net::calc
(
    Scene* aScene
)
{

//    /* Load images in to layers */
//    for( int i = 0; i < c; i++ )
//    {
//        Layer* layer = ( Layer* ) layers -> getByIndex( i );
//        layer -> applyImage();
//    }

    /* Load layers from storage */
    loadLayers();

    /* Get counts of layer */
    int c = layers -> getCount();

    /* Calculate values */
    bool valueFinish = true;
    for( int i = 0; i < c; i++ )
    {
        Layer* layer = ( Layer* ) layers -> getByIndex( i );
        if( layer -> getLoopParityValue() != loopParity )
        {
            layer -> calcValue( loopParity );
            valueFinish = valueFinish && layer -> getLoopParityValue() == loopParity;
        }
    }

    if( valueFinish )
    {
        if( learningMode )
        {
            /* Calculate errors */
            bool errorFinish = true;
            for( int i = c - 1; i >= 0; i-- )
            {
                Layer* layer = ( Layer* ) layers -> getByIndex( i );
                if( layer -> getLoopParityError() != loopParity )
                {
                    layer -> learning
                    (
                        loopParity,
                        errorNormalize,
                        learningSpeed,
                        wakeupWeight
                    );
                    errorFinish = errorFinish && layer -> getLoopParityError() == loopParity;
                }
            }
            if( errorFinish )
            {
                loopParity = !loopParity;
            }
        }
        else
        {
            loopParity = !loopParity;
        }
    }

    /* Store layers to storage */
    saveLayers();

    return this;
}




/*
    Load layers
*/
Net* Net::loadLayers()
{
    layers -> loop
    (
        []
        ( void* iLayer )
        {
            auto layer = (( Layer* ) iLayer );
            if( layer -> getRead() )
            {
                layer -> loadValue();
            }
            return false;
        }
    );
    return this;
}



/*
    Save layers
*/
Net* Net::saveLayers()
{
    layers -> loop
    (
        []
        ( void* iLayer )
        {
            auto layer = (( Layer* ) iLayer );
            if( layer -> getWrite() )
            {
                layer -> saveValue();
            }
            return false;
        }
    );
    return this;
}



/*
    Return application object
*/
Application* Net::getApplication()
{
    return application;
}



/*
    Return log object
*/
Log* Net::getLog()
{
    return application -> getLog();
}




/*
    Return neuron by screen position
*/
Net* Net::getNeuronsByScreenPos
(
    NeuronList* aList,
    const Point3d& aPosition
)
{
    int c = layers -> getCount();
    for( int i = 0; i < c; i++ )
    {
        Layer* layer = ( Layer* ) layers -> getByIndex( i );
        layer -> getNeuronsByScreenPos( aList, aPosition );
    }
    return this;
}



Net* Net::setSelected
(
    Neuron* a
)
{
    selected = a;
    return this;
}



Neuron* Net::getSelected()
{
    return selected;
}




/*
    On mouse left click event
*/
Net* Net::setSelected
(
    Scene& aScene /* Scene object */
)
{
    auto neurons = NeuronList::create();
    getNeuronsByScreenPos( neurons, aScene.getMouseCurrentScreen() );

    if( neurons -> getCount() > 0 )
    {
        setSelected( neurons -> getByIndex( 0 ));
    }
    else
    {
        setSelected( NULL );
    }

    neurons -> destroy();

    return this;
}




Net* Net::switchShowLayer()
{
    int c = layers -> getCount();
    for( int i = 0; i < c; i++ )
    {
        Layer* layer = ( Layer* ) layers -> getByIndex( i );
        layer -> switchShowLayer();
    }
    return this;
}



/*
    Set learning mode
*/
Net* Net::setLearningMode
(
    bool a /* Value */
)
{
    learningMode = a;
    return this;
}



/*
    Get learning mode
*/
bool Net::getLearningMode()
{
    return learningMode;
}



/*
    Switch learning mode true/false
*/
Net* Net::switchLearningMode()
{
    learningMode = !learningMode;
    return this;
}



/*
    Apply config from Json
*/
Net* Net::applyConfig
(
    ParamList* json
)
{
    setLearningSpeed( json -> getDouble( "learningSpeed", getLearningSpeed() ));
    setWakeupWeight( json -> getDouble( "wakeupWeight", getWakeupWeight() ));
    setErrorNormalize( json -> getDouble( "errorNormalize", getErrorNormalize() ));
    setStoragePath( json -> getString( "storagePath", getStoragePath() ));


    use();


    /* Nerves */
    auto jsonNerves = json -> getObject( "nerves" );
    if( jsonNerves != NULL )
    {
        jsonNerves -> loop
        (
            [ this ]
            ( Param* aItem )
            {
                /* Check the json layer */
                if( aItem -> getType() == KT_OBJECT )
                {
                    auto jsonNerve      = aItem -> getObject();
                    auto idFrom         = jsonNerve -> getString( "idFrom" );
                    auto idTo           = jsonNerve -> getString( "idTo" );
                    auto bindType       = Bind::bindTypeFromString( jsonNerve -> getString( "bindType" ));
                    auto nerveType      = Bind::nerveTypeFromString( jsonNerve -> getString( "nerveType" ));
                    auto nerveDelete    = jsonNerve -> getBool( "delete" );
                    auto idNerve        = jsonNerve -> getString( "id", idFrom + "_" + idTo + "_" + jsonNerve -> getString( "bindType" ));

                    /* Find the layers */
                    auto from = layers -> getById( idFrom );
                    auto to = layers -> getById( idTo );

                    if( from != NULL && to != NULL )
                    {
                        auto nerve = nerves -> getById( idNerve );
                        if
                        (
                            nerve != NULL &&
                            (
                                nerve -> getParent() != from ||
                                nerve -> getChild() != to ||
                                nerve -> getBindType() != bindType ||
                                nerve -> getNerveType() != nerveType ||
                                nerveDelete
                            )
                        )
                        {
                            deleteNerve( idNerve );
                            nerve = NULL;
                        }

                        if( nerve == NULL && !nerveDelete )
                        {
                            createNerve
                            (
                                idNerve,
                                from,
                                to,
                                nerveType,
                                bindType,
                                jsonNerve -> getDouble( "minWeight", 1.0 ),
                                jsonNerve -> getDouble( "maxWeight", 1.0 )
                            );
                        }
                    }
                    else
                    {
                        getLog() -> warning( "Layers not found for nerve" ) . prm( "id", idNerve );
                    }
                }
                return false;
            }
        );
    }

    return this;
}



/*
    Return layer list
*/
LayerList* Net::getLayers()
{
    return layers;
}





/*
    Set learning speed
*/
Net* Net::setLearningSpeed
(
    double a
)
{
    learningSpeed = a;
    return this;
}



/*
    Set wakeup weight
*/
Net* Net::setWakeupWeight
(
    double a
)
{
    wakeupWeight = a;
    return this;
}



/*
    Set error normalize
*/
Net* Net::setErrorNormalize
(
    double a
)
{
    errorNormalize = a;
    return this;
}



/*
    Get learning speed
*/
double Net::getLearningSpeed()
{
    return learningSpeed;
}



/*
    Get wakeup weight k
*/
double Net::getWakeupWeight()
{
    return wakeupWeight;
}



/*
    Get error normalize
*/
double Net::getErrorNormalize()
{
    return errorNormalize;
}




Net* Net::setStoragePath
(
    const string a
)
{
    storagePath = a;
    return this;
}



string Net::getStoragePath()
{
    return storagePath;
}



/*
    Return list ov nerves
*/
NerveList* Net::getNerves()
{
    return  nerves;
}



/******************************************************************************
    Layers
*/


/*
    Return layer by Id
*/
Layer* Net::getLayerById
(
    string a /* Id of layer */
)
{
    Layer* result = NULL;
    int c = layers -> getCount();
    for( int i=0; i < c && result == NULL; i++ )
    {
        Layer* iLayer = layers -> getByIndex( i );
        if( iLayer -> getId() == a )
        {
            result = iLayer;
        }
    }
    return result;
}



/*
    Create new layer
*/
Layer* Net::createLayer
(
    string a /* Id of layer */
)
{
    Layer* result = NULL;

    int layerIndex = layers -> getIndexById( a );

    if( layerIndex > -1 )
    {
        /* Return exists layer object */
        result = layers -> getByIndex( layerIndex );
    }
    else
    {
        /* Create new layer object */
        result = Layer::create( getLog(), a );
        layers -> push( result );
        result -> setStoragePath( getStoragePath() );
    }

    return result;
}



/*
    Delete layer by Id
*/
Net* Net::deleteLayer
(
    string a /* Id of layer */
)
{
    int layerIndex = layers -> getIndexById( a );
    if( layerIndex > -1 )
    {
        /* Define layer for remove */
        Layer* layer = layers -> getByIndex( layerIndex );

        /* Destroy nerves for layer */
        nerves -> removeByLayer( layer );

        /* Remove layer from layer list */
        layers -> remove( layerIndex );

        /* Destroy layer */
        layer -> destroy();
    }
    return this;
}




/*
    Load layer structure from param list
    Layer may be resized.
*/
Net* Net::loadLayer
(
    Layer*      aLayer,
    ParamList*  aParams
)
{
    if( this -> isOk() )
    {
        /* Set ID from params */
        if( aLayer-> getId() != aParams -> getString( "id", aLayer -> getId() ))
        {
            setCode( "InvalidLayerID" );
        }
        else
        {
            /* Set Size from params */
            auto paramsSize = aParams -> getObject( "size" );
            if( paramsSize != NULL )
            {
                auto newSize = Point3i
                (
                    paramsSize -> getInt( 0 ),
                    paramsSize -> getInt( 1 ),
                    paramsSize -> getInt( 2 )
                );

                if( newSize != aLayer -> getSize() )
                {
                    nerves -> removeByLayer( aLayer );
                }

                /* Update layer */
                aLayer
                -> setSize( aParams )
                -> setPosition( aParams )
                ;
            }
        }

    }
    return this;
}



/*
    Load layer from net.layers section
*/
Layer* Net::loadLayerFromConfig
(
    string aLayerId,    /* ID of the layer */
    ParamList* aParams  /* Param list with layers key */
)
{
    Layer* result = NULL;
    if( aParams != NULL )
    {
        if( this -> isOk() )
        {
            auto params = aParams -> getObject( vector <string> { "layers" }, "id", aLayerId );
            if( params )
            {
                result = createLayer( aLayerId );
                loadLayer( result, params );
            }
            else
            {
                getLog() -> warning( "Layer not found" ).prm( "id", aLayerId  );
                setCode( "LayerIdNotFound" );
            }
        }
    }
    else
    {
        setCode( "ParamsIsEmptyForLayer" );
    }
    return result;
}



/*
    Remove layers absent in the list
*/
Net* Net::purgeLayers
(
    ParamList* aUse
)
{
    /* Build pure list */
    vector <string> purgeList = {};
    layers -> loop
    (
        [ &purgeList, &aUse ]
        ( void* iLayer )
        {
            auto layerId = ((Layer*) iLayer ) -> getId();
            if( aUse -> getObject( layerId ) == NULL )
            {
                /* Layer is absent */
                purgeList.push_back( layerId );
            }
            return false;
        }
    );

    /* Delete layers */
    auto c = purgeList.size();
    for( int i = 0; i<c; i++ )
    {
        deleteLayer( purgeList[ i ] );
    }
    return this;
}



/*
    Use the layers from config
*/
Net* Net::use()
{
    auto use = getApplication() -> getConfig() -> getObject( "use" );

    if( use != NULL )
    {
        /* Remove layers absents in the use list */
        purgeLayers( use );

        /* Create and reload layers */
        use -> loop
        (
            [ this ]
            (
                Param* iParam
            )
            {
                auto rules = iParam -> getObject();
                auto layerId = iParam -> getName();

                auto layer = createLayer( layerId );
                if( rules != NULL )
                {
                    layer
                    -> setWrite( rules -> contains( "write" ))
                    -> setRead( rules -> contains( "read" ))
                    -> setCalc( rules -> contains( "calc" ));
                }
                loadLayerFromConfig
                (
                    layerId,
                    getApplication() -> getConfig()
                );
                return false;
            }
        );
    }
    return this;
}
